// AUTOGENERATED! DO NOT EDIT.
package accountingV2

import (
    "context"
    "fmt"
	"net/http"
    "encoding/json"

	"github.com/go-chi/chi/v5"

	"tonky/holistic/domain/foodStore"

	app "tonky/holistic/apps/accountingV2"

	"tonky/holistic/infra/kafkaProducer"
	"tonky/holistic/infra/kafkaConsumer"
    "tonky/holistic/clients/pricingClient"
	"tonky/holistic/infra/logger"
)

type handlers struct {
    config Config
    app app.App
    deps app.Deps
    mux *chi.Mux
}

func (h handlers) GetOrderByID() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var in foodStore.OrderID
        var out foodStore.Order

        if err := json.NewDecoder(r.Body).Decode(&in); err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }

        var appErr error

        out, appErr = h.app.GetOrderByID(context.TODO(), in)

        if appErr != nil {
            http.Error(w, appErr.Error(), http.StatusInternalServerError)
            return
        }

        byteResp, err := json.Marshal(out)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        w.Write(byteResp)
    }
}

func (h handlers) CreateOrder() http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var in NewFoodOrder
        var out foodStore.Order

        if err := json.NewDecoder(r.Body).Decode(&in); err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }

        var appErr error

        out, appErr = h.app.CreateOrder(context.TODO(), serviceToAppNewFoodOrder(in))

        if appErr != nil {
            http.Error(w, appErr.Error(), http.StatusInternalServerError)
            return
        }

        byteResp, err := json.Marshal(out)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        w.Write(byteResp)
    }
}


func NewMux(conf Config, deps app.Deps, clients app.Clients) (*chi.Mux, error) {
	a, err := app.NewApp(deps, clients)
	if err != nil {
		panic(err)
	}

	r := chi.NewRouter()

    h := handlers{deps: deps, app: *a, config: conf, mux: r}

	r.Post("/GetOrderByID", h.GetOrderByID())
	r.Post("/CreateOrder", h.CreateOrder())

    return r, nil
}

func NewFromEnv() (ServiceStarter, error) {
	cfg, err := NewEnvConfig()
    if err != nil {
        return nil, err
    }

    deps := app.Deps{
        Logger: &logger.Slog{},
    }

	AccountingOrderPaidProducer, err := kafkaProducer.NewAccountingOrderPaidProducer(*deps.Logger, cfg.App.Kafka)
    if err != nil {
        return nil, err
    }
	deps.AccountingOrderPaidProducer = AccountingOrderPaidProducer
	FoodOrderUpdatedConsumer, err := kafkaConsumer.NewFoodOrderUpdatedConsumer(*deps.Logger, cfg.App.Kafka)
    if err != nil {
        return nil, err
    }
	deps.FoodOrderUpdatedConsumer = FoodOrderUpdatedConsumer
    clients := app.Clients{
        PricingClient: pricingClient.NewFromEnv(cfg.Environment),
    }

    application, appErr := app.NewApp(deps, clients)
    if appErr != nil {
        return nil, appErr
    }

    mux, err := NewMux(cfg, deps, clients)
    if err != nil { return nil, err}

    handlers := handlers{config: cfg, app: *application, deps: deps, mux: mux}

    return handlers, nil
}

func (h handlers) Config() Config {
    return h.config
}

func (h handlers) Start() error {
    fmt.Printf(">> accountingV2.Start() config: %+v\n", h.config)
    h.app.RunConsumers()

    return http.ListenAndServe(fmt.Sprintf(":%d", h.config.Port), h.mux)
}

func (h handlers) Deps() app.Deps {
    return h.deps
}

func (h handlers) Mux() *chi.Mux {
    return h.mux
}

type ServiceStarter interface {
    Start() error
    Config() Config
    Deps() app.Deps
    Mux() *chi.Mux
}
