// AUTOGENERATED! DO NOT EDIT.
package accounting

import (
    "context"
    "fmt"
	"log"
	"net"
	"net/rpc"

	"tonky/holistic/infra/kafkaProducer"
	"tonky/holistic/infra/kafkaConsumer"

    // "github.com/go-playground/validator/v10"


	"tonky/holistic/domain/food"
	"tonky/holistic/domain/accounting"
	app "tonky/holistic/apps/accounting"
	"tonky/holistic/infra/logger"
	"tonky/holistic/clients/pricingClient"
)

type Accounting struct {
    config Config
    deps app.Deps
    app app.App
}

func (h Accounting) ReadOrder(arg food.OrderID, reply *accounting.Order) error {
    res, err := h.app.ReadOrder(context.TODO(), arg)
    if err != nil {
        return err
    }

    *reply = res

    return nil
}


func New(deps app.Deps, clients app.Clients) (ServiceStarter, error) {
	cfg, err := NewEnvConfig()
    if err != nil {
        return nil, err
    }

    application, appErr := app.NewApp(deps, clients)
    if appErr != nil {
        return nil, appErr
    }

    handlers := Accounting{deps: deps, config: cfg, app: *application}

    return handlers, nil
}

func (h Accounting) Start() error {
	port := h.config.Port

    fmt.Printf(">> accounting.Start() config: %+v\n", h.config)
    h.app.RunConsumers()

	server := rpc.NewServer()
	server.Register(h)

	fmt.Println(">> starting server on port ", port)

	l, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
    if err != nil {
        log.Fatal("listen error:", err)
    }

	for {
		conn, err := l.Accept()
		if err != nil {
			panic(err)
		}

		go func() {
			server.ServeConn(conn)
		}()
	}
}
// TODO: REMOVE

func NewFromEnv() (ServiceStarter, error) {
	cfg, err := NewEnvConfig()
    if err != nil {
        return nil, err
    }

    // plain deps code here
    deps := app.Deps{
        Logger: &logger.Slog{},
    }

	ordererRepo, err := app.NewPostgresOrderer(*deps.Logger, cfg.App.PostgresOrderer)
    if err != nil {
        return nil, err
    }

	deps.OrdererRepo = ordererRepo

	AccountingOrderPaidProducer, err := kafkaProducer.NewAccountingOrderPaidProducer(*deps.Logger, cfg.App.Kafka)
    if err != nil {
        return nil, err
    }

	deps.AccountingOrderPaidProducer = AccountingOrderPaidProducer

	FoodOrderUpdatedConsumer, err := kafkaConsumer.NewFoodOrderUpdatedConsumer(*deps.Logger, cfg.App.Kafka)
    if err != nil {
        return nil, err
    }

	deps.FoodOrderUpdatedConsumer = FoodOrderUpdatedConsumer

    clients := app.Clients {
        PricingClient: pricingClient.NewFromEnv(cfg.Environment),
    }

    application, appErr := app.NewApp(deps, clients)
    if appErr != nil {
        return nil, appErr
    }

    handlers := Accounting{deps: deps, config: cfg, app: *application}

    return handlers, nil
}

func (h Accounting) Config() Config {
    return h.config
}

func (h Accounting) Deps() app.Deps {
    return h.deps
}


type ServiceStarter interface {
    Start() error
    Config() Config
    Deps() app.Deps
}
