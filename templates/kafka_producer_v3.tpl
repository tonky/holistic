// AUTOGENERATED! DO NOT EDIT.
package kafkaProducer

import (
	"context"
	"encoding/json"
	"tonky/holistic/infra/tele"
	"tonky/holistic/infra/kafka"

	{% for i in topic.Obj.AbsImports(ctx) %}
	"{{ i }}"
	{% end %}
)

// compile-time check to make sure app-level interface is implemented
var _ {{ topic.InterfaceName() }} = new({{ topic.StructName() }}Producer) 

type {{ topic.InterfaceName() }} interface {
	Produce{{ cap(topic.Name) }}(context.Context, {{ topic.ModelName() }}) error
	Produce{{ cap(topic.Name) }}Batch(context.Context, []{{ topic.ModelName() }}) error
}

type {{ topic.StructName() }}Producer struct {
    lmt tele.Otel
	client kafka.IProducer
}

func New{{ topic.StructName() }}Producer(lmt tele.Otel, config kafka.Config) (*{{ topic.StructName() }}Producer, error) {
	client := kafka.NewProducer(config, "{{ topic.TopicName }}")

	return &{{ topic.StructName() }}Producer {
		lmt: lmt,
		client: client,
	}, nil
}

func (r {{ topic.StructName() }}Producer) Produce{{ cap(topic.Name) }}(ctx context.Context, in {{ topic.ModelName() }}) error {
	r.lmt.Logger.Info("{{ topic.StructName() }}.Produce{{ cap(topic.Name) }}", in)

	inBytes, err := json.Marshal(in)
	if err != nil {
		return err
	}

	return r.client.Produce(ctx, inBytes)
}

func (r {{ topic.StructName() }}Producer) Produce{{ cap(topic.Name) }}Batch(ctx context.Context, ins []{{ topic.ModelName() }}) error {
	r.lmt.Logger.Info("{{ topic.StructName() }}.Produce{{ cap(topic.Name) }}Batch", ins)

	var data [][]byte

	for _, in  := range ins {
		inBytes, err := json.Marshal(in)
		if err != nil {
			return err
		}
	
		data = append(data, inBytes)
	}

	return r.client.ProduceBatch(ctx, data)
}
