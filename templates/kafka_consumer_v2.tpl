// AUTOGENERATED! DO NOT EDIT.
package kafkaConsumer

import (
	"context"
	"encoding/json"
	"tonky/holistic/infra/tele"
	"tonky/holistic/infra/kafka"

	{% for i in topic.Obj.AbsImports(ctx) %}
	"{{ i }}"
	{% end %}
)

// compile-time check to make sure app-level interface is implemented
var _ {{ topic.InterfaceName() }} = new({{ topic.StructName() }}Consumer) 

type {{ topic.InterfaceName() }} interface {
	Run(context.Context, func(context.Context, {{ topic.ModelName() }}) error) chan error
}

type {{ topic.StructName() }}Consumer struct {
	lmt tele.Otel
	client kafka.IConsumer
}

func New{{ topic.StructName() }}Consumer(lmt tele.Otel, config kafka.Config) (*{{ topic.StructName() }}Consumer, error) {
	lmt.Logger = lmt.Logger.With("kafkaConsumer", "{{ topic.StructName() }}Consumer", "topic", "{{ topic.TopicName }}", "groupID", config.GroupID)
	
	lmt.Logger.Info("New consumer")

	client := kafka.NewConsumer(config, "{{ topic.TopicName }}")

	return &{{ topic.StructName() }}Consumer {
		lmt: lmt,
		client: client,
	}, nil
}

func (c {{ topic.StructName() }}Consumer) Run(ctx context.Context, processor func(context.Context, {{ topic.ModelName() }}) error) chan error {
	c.lmt.Logger.Info("{{ topic.StructName() }}.Run()")

	res := make(chan error)
	models, errors := c.Chan(ctx)

	go func() {
		for {
			select {
			case model := <-models:
				c.lmt.Logger.Info("got model", model)

				if err := processor(ctx, model); err != nil {
					res <- err
				}
			case err := <-errors:
				res <- err
			case <-ctx.Done():
				return
			}
		}
	}()

	return res
}

func (c {{ topic.StructName() }}Consumer) Chan(ctx context.Context)(chan {{ topic.ModelName() }}, chan error) {
	models := make(chan {{ topic.ModelName() }})
	errors := make(chan error)

	kafkaMessages, kafkaErrors := c.client.Consume(context.Background())

	go func() {
		for {
			select {
			case err := <-kafkaErrors:
				errors <- err
			case <-ctx.Done():
				close(models)
				return
			case msg := <-kafkaMessages:
				var model {{ topic.ModelName() }}
				if err := json.Unmarshal(msg.Value, &model); err != nil {
					errors <- err
					continue
				}
				models <- model
			}
		}
	}()

	return models, errors
}
