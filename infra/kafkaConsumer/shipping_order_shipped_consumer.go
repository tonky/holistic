// AUTOGENERATED! DO NOT EDIT.
package kafkaConsumer

import (
	"context"
	"encoding/json"
	"tonky/holistic/infra/logger"
	"tonky/holistic/infra/kafka"

	"tonky/holistic/domain/shipping"
)

// compile-time check to make sure app-level interface is implemented
var _ IShippingOrderShipped = new(ShippingOrderShipped) 

type IShippingOrderShipped interface {
	Run(context.Context, func(context.Context, shipping.Order) error) chan error
}

type ShippingOrderShipped struct {
	logger logger.ILogger
	client IConsumer
}

func NewShippingOrderShippedConsumer(l logger.ILogger, config kafka.Config) (*ShippingOrderShipped, error) {
	// l = l.With("kafkaConsumer", "ShippingOrderShippedConsumer", "topic", "shipping.order.shipped", "groupID", config.GroupID)
	// l.Info("New consumer")

	client := NewConsumer(config, "shipping.order.shipped")

	return &ShippingOrderShipped{
		logger: l,
		client: client,
	}, nil
}

func (c ShippingOrderShipped) Run(ctx context.Context, processor func(context.Context, shipping.Order) error) chan error {
	c.logger.Info("ShippingOrderShipped.Run()", "topic", c.client.Topic())

	res := make(chan error)
	models, errors := ConsumeShippingOrderShipped(ctx, c.client)

	go func() {
		for {
			select {
			case model := <-models:
				c.logger.Info("kafkaConsumer.ShippingOrderShipped got model in channel", "model", model)

				if err := processor(ctx, model); err != nil {
					res <- err
				}
			case err := <-errors:
				res <- err
			case <-ctx.Done():
				return
			}
		}
	}()

	return res
}

func ConsumeShippingOrderShipped(ctx context.Context, client IConsumer) (chan shipping.Order, chan error) {
	client.Logger().Info("consumer.ConsumeShippingOrderShipped", "topic", client.Topic())

	models := make(chan shipping.Order)
	errors := make(chan error)

	kafkaMessages, kafkaErrors := client.Consume(context.Background())

	go func() {
		for {
			select {
			case err := <-kafkaErrors:
				errors <- err
			case <-ctx.Done():
				close(models)
				return
			case msg := <-kafkaMessages:
				var model shipping.Order
				if err := json.Unmarshal(msg.Value, &model); err != nil {
					errors <- err
					continue
				}
				models <- model
			}
		}
	}()

	return models, errors
}
